#version 430 core

// particle_update.comp - Particle physics update compute shader
// Updates particle position, velocity, lifetime, handles forces and collisions
// Supports VelocityOverLifetime, RotationOverLifetime, and dead particle tracking

layout(local_size_x = 256) in;

// ==================== Data Structures ====================

struct Particle {
    vec4 position;  // xyz: position, w: current lifetime
    vec4 velocity;  // xyz: velocity, w: max lifetime
    vec4 color;     // rgba
    vec4 params;    // x: size, y: rotation, z: type, w: angular velocity
};

struct Force {
    int type;       // force type
    vec3 position;  // position/direction
    float strength; // strength
    float param1;   // extra param 1
    float param2;   // extra param 2
    vec3 axis;      // axis vector
    float enabled;  // is enabled
};

// ==================== Buffer Bindings ====================

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(binding = 1) uniform atomic_uint aliveCount;

// Dead particle buffer for sub-emitter support
layout(std430, binding = 2) buffer DeadParticleBuffer {
    vec4 deadParticles[];  // xyz: position, w: velocity magnitude (for sub-emitter inheritance)
};

layout(binding = 3) uniform atomic_uint deadCount;

// ==================== Uniforms ====================

uniform float uDeltaTime;
uniform int uParticleCount;
uniform int uForceCount;
uniform int uCollisionMode;
uniform int uCollisionResponse;
uniform float uBounciness;
uniform float uBounceChance;     // Bounce probability (0-1)
uniform float uBounceSpread;     // Bounce velocity spread (degrees)
uniform int uRandomSeed;         // Deterministic random seed
uniform int uMaxDeadParticles;   // Max dead particles to track (0 = disabled)

// Force data (max 16)
uniform float uForces[192]; // 16 * 12 floats

// Collision plane params
uniform vec4 uCollisionPlane; // xyz: normal, w: distance

// Collision sphere params
uniform vec3 uCollisionSphereCenter;
uniform float uCollisionSphereRadius;

// Collision box params
uniform vec3 uCollisionBoxMin;
uniform vec3 uCollisionBoxMax;

// Velocity over lifetime curve (max 16 keyframes)
uniform int uVelocityOverLifetimeEnabled;
uniform int uVelocityOverLifetimeKeyCount;
uniform float uVelocityOverLifetimeCurve[64]; // [time0, valueX0, valueY0, valueZ0, time1, ...]
uniform int uVelocitySeparateAxes;             // 0: uniform, 1: separate XYZ

// Rotation over lifetime curve (max 16 keyframes)
uniform int uRotationOverLifetimeEnabled;
uniform int uRotationOverLifetimeKeyCount;
uniform float uRotationOverLifetimeCurve[32]; // [time0, value0, time1, value1, ...]

// Initial velocity storage (stored in velocity.w during emit, moved to params.z)
// For VelocityOverLifetime, we need to know original velocity direction

// ==================== Force Type Constants ====================

const int FORCE_GRAVITY = 0;
const int FORCE_WIND = 1;
const int FORCE_VORTEX = 2;
const int FORCE_TURBULENCE = 3;
const int FORCE_ATTRACTOR = 4;
const int FORCE_REPULSOR = 5;
const int FORCE_DRAG = 6;
const int FORCE_CURL_NOISE = 7;
const int FORCE_ORBITAL = 8;
const int FORCE_VELOCITY_LIMIT = 9;
const int FORCE_VECTOR_FIELD = 10;
const int FORCE_SPRING = 11;

// Collision mode constants
const int COLLISION_NONE = 0;
const int COLLISION_WORLD = 1;
const int COLLISION_PLANE = 2;
const int COLLISION_SPHERE = 3;
const int COLLISION_BOX = 4;

// Collision response constants
const int RESPONSE_KILL = 0;
const int RESPONSE_BOUNCE = 1;
const int RESPONSE_BOUNCE_DAMPED = 2;
const int RESPONSE_STICK = 3;
const int RESPONSE_SLIDE = 4;

// ==================== Noise Functions ====================

uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float hashFloat(uint x) {
    return float(hash(x)) / 4294967295.0;
}

float noise3D(vec3 p) {
    uvec3 i = uvec3(floor(p));
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);

    float n = float(i.x + i.y * 57u + i.z * 113u);
    return mix(
        mix(mix(hashFloat(uint(n)), hashFloat(uint(n + 1.0)), f.x),
            mix(hashFloat(uint(n + 57.0)), hashFloat(uint(n + 58.0)), f.x), f.y),
        mix(mix(hashFloat(uint(n + 113.0)), hashFloat(uint(n + 114.0)), f.x),
            mix(hashFloat(uint(n + 170.0)), hashFloat(uint(n + 171.0)), f.x), f.y),
        f.z
    ) * 2.0 - 1.0;
}

vec3 curlNoise(vec3 p) {
    const float e = 0.1;
    vec3 dx = vec3(e, 0.0, 0.0);
    vec3 dy = vec3(0.0, e, 0.0);
    vec3 dz = vec3(0.0, 0.0, e);

    float n1 = noise3D(p + dy) - noise3D(p - dy);
    float n2 = noise3D(p + dz) - noise3D(p - dz);
    float n3 = noise3D(p + dx) - noise3D(p - dx);

    vec3 offset = vec3(31.341, 57.127, 93.853);
    float m1 = noise3D(p + dy + offset) - noise3D(p - dy + offset);
    float m2 = noise3D(p + dz + offset) - noise3D(p - dz + offset);
    float m3 = noise3D(p + dx + offset) - noise3D(p - dx + offset);

    return vec3(n2 - m1, m3 - n2, n1 - m3) / (2.0 * e);
}

// ==================== Curve Evaluation ====================

// Evaluate uniform curve (for velocity or rotation)
float evaluateCurve(float t, int keyCount, float curve[64], int stride) {
    if (keyCount <= 0) return 1.0;
    if (keyCount == 1) return curve[1]; // Single key, return value

    // Find surrounding keyframes
    int prevIdx = 0;
    int nextIdx = 0;

    for (int i = 0; i < keyCount; i++) {
        int base = i * stride;
        if (curve[base] <= t) {
            prevIdx = i;
        }
        if (curve[base] >= t && nextIdx == 0) {
            nextIdx = i;
            break;
        }
    }

    // Clamp to last key if beyond
    if (nextIdx == 0) nextIdx = keyCount - 1;

    int prevBase = prevIdx * stride;
    int nextBase = nextIdx * stride;

    // Interpolate
    if (prevIdx == nextIdx) {
        return curve[prevBase + 1];
    }

    float t0 = curve[prevBase];
    float t1 = curve[nextBase];
    float v0 = curve[prevBase + 1];
    float v1 = curve[nextBase + 1];

    float factor = (t - t0) / max(t1 - t0, 0.0001);
    return mix(v0, v1, factor);
}

// Evaluate velocity curve (returns multiplier for velocity)
vec3 evaluateVelocityOverLifetime(float lifePercent) {
    if (uVelocityOverLifetimeEnabled == 0 || uVelocityOverLifetimeKeyCount <= 0) {
        return vec3(1.0);
    }

    if (uVelocitySeparateAxes == 0) {
        // Uniform mode: apply same multiplier to all axes
        float v = evaluateCurve(lifePercent, uVelocityOverLifetimeKeyCount, uVelocityOverLifetimeCurve, 2);
        return vec3(v);
    } else {
        // Separate axes mode: each axis has its own curve
        // Data layout: [t0, x0, y0, z0, t1, x1, y1, z1, ...]
        int keyCount = uVelocityOverLifetimeKeyCount;

        // Find keyframes
        int prevIdx = 0;
        int nextIdx = 0;

        for (int i = 0; i < keyCount; i++) {
            int base = i * 4;
            if (uVelocityOverLifetimeCurve[base] <= lifePercent) {
                prevIdx = i;
            }
            if (uVelocityOverLifetimeCurve[base] >= lifePercent && nextIdx == 0) {
                nextIdx = i;
                break;
            }
        }

        if (nextIdx == 0) nextIdx = keyCount - 1;

        int prevBase = prevIdx * 4;
        int nextBase = nextIdx * 4;

        if (prevIdx == nextIdx) {
            return vec3(uVelocityOverLifetimeCurve[prevBase + 1],
                       uVelocityOverLifetimeCurve[prevBase + 2],
                       uVelocityOverLifetimeCurve[prevBase + 3]);
        }

        float t0 = uVelocityOverLifetimeCurve[prevBase];
        float t1 = uVelocityOverLifetimeCurve[nextBase];
        float factor = (lifePercent - t0) / max(t1 - t0, 0.0001);

        vec3 v0 = vec3(uVelocityOverLifetimeCurve[prevBase + 1],
                      uVelocityOverLifetimeCurve[prevBase + 2],
                      uVelocityOverLifetimeCurve[prevBase + 3]);
        vec3 v1 = vec3(uVelocityOverLifetimeCurve[nextBase + 1],
                      uVelocityOverLifetimeCurve[nextBase + 2],
                      uVelocityOverLifetimeCurve[nextBase + 3]);

        return mix(v0, v1, factor);
    }
}

// Evaluate rotation curve (returns additional angular velocity in radians/sec)
float evaluateRotationOverLifetime(float lifePercent) {
    if (uRotationOverLifetimeEnabled == 0 || uRotationOverLifetimeKeyCount <= 0) {
        return 0.0;
    }

    return evaluateCurve(lifePercent, uRotationOverLifetimeKeyCount, uRotationOverLifetimeCurve, 2);
}

// ==================== Force Calculation ====================

Force getForce(int index) {
    int base = index * 12;
    Force f;
    f.type = int(uForces[base]);
    f.position = vec3(uForces[base + 1], uForces[base + 2], uForces[base + 3]);
    f.strength = uForces[base + 4];
    f.param1 = uForces[base + 5];
    f.param2 = uForces[base + 6];
    f.axis = vec3(uForces[base + 8], uForces[base + 9], uForces[base + 10]);
    f.enabled = uForces[base + 11];
    return f;
}

vec3 applyForce(Force f, vec3 pos, vec3 vel) {
    if (f.enabled < 0.5) return vec3(0.0);

    vec3 force = vec3(0.0);

    switch (f.type) {
        case FORCE_GRAVITY:
            force = f.position * f.strength;
            break;

        case FORCE_WIND:
            force = f.position * f.strength;
            if (f.param1 > 0.0) {
                force += curlNoise(pos * f.param1) * f.strength * 0.3;
            }
            break;

        case FORCE_VORTEX: {
            vec3 toCenter = f.position - pos;
            vec3 axis = normalize(f.axis);
            vec3 radial = toCenter - dot(toCenter, axis) * axis;
            vec3 tangent = cross(axis, radial);
            force = normalize(tangent) * f.strength;
            break;
        }

        case FORCE_TURBULENCE:
            force = curlNoise(pos * f.param1) * f.strength;
            break;

        case FORCE_ATTRACTOR: {
            vec3 toCenter = f.position - pos;
            float dist = length(toCenter);
            if (dist > 0.01 && (f.param1 <= 0.0 || dist < f.param1)) {
                float falloff = f.param1 > 0.0 ? 1.0 - dist / f.param1 : 1.0;
                force = normalize(toCenter) * f.strength * falloff * falloff;
            }
            break;
        }

        case FORCE_REPULSOR: {
            vec3 fromCenter = pos - f.position;
            float dist = length(fromCenter);
            if (dist > 0.01 && (f.param1 <= 0.0 || dist < f.param1)) {
                float falloff = f.param1 > 0.0 ? 1.0 - dist / f.param1 : 1.0;
                force = normalize(fromCenter) * f.strength * falloff * falloff;
            }
            break;
        }

        case FORCE_DRAG:
            force = -vel * f.strength;
            break;

        case FORCE_CURL_NOISE:
            force = curlNoise(pos * f.param1) * f.strength;
            break;

        case FORCE_ORBITAL: {
            vec3 toCenter = f.position - pos;
            float dist = length(toCenter);
            if (dist > 0.01) {
                vec3 radial = normalize(toCenter);
                vec3 up = vec3(0, 1, 0);
                vec3 tangent = normalize(cross(up, radial));
                force = tangent * f.strength + radial * f.param1;
            }
            break;
        }

        case FORCE_VELOCITY_LIMIT: {
            float speed = length(vel);
            if (speed > f.strength) {
                force = -vel * (1.0 - f.strength / speed);
            }
            break;
        }

        case FORCE_SPRING: {
            vec3 displacement = f.position - pos;
            force = displacement * f.strength - vel * f.param1;
            break;
        }
    }

    return force;
}

// ==================== Deterministic Random ====================

float particleRandom(uint particleIdx, uint channel) {
    uint seed = particleIdx * 7919u + uint(uRandomSeed) * 104729u + channel * 31337u;
    return hashFloat(hash(seed));
}

vec3 randomSpread(uint particleIdx, vec3 baseDir, float spreadAngle) {
    if (spreadAngle <= 0.0) return baseDir;

    float theta = particleRandom(particleIdx, 0u) * 6.28318530718;
    float phi = particleRandom(particleIdx, 1u) * spreadAngle * 0.0174532925;

    vec3 up = abs(baseDir.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, baseDir));
    vec3 bitangent = cross(baseDir, tangent);

    float sinPhi = sin(phi);
    float cosPhi = cos(phi);
    vec3 offset = tangent * (sinPhi * cos(theta)) + bitangent * (sinPhi * sin(theta));

    return normalize(baseDir * cosPhi + offset);
}

// ==================== Collision Detection ====================

bool checkPlaneCollision(vec3 pos, vec3 vel, vec4 plane, out vec3 hitPoint, out vec3 normal) {
    float dist = dot(pos, plane.xyz) - plane.w;
    if (dist < 0.0) {
        hitPoint = pos - plane.xyz * dist;
        normal = plane.xyz;
        return true;
    }
    return false;
}

bool checkSphereCollision(vec3 pos, vec3 center, float radius, out vec3 hitPoint, out vec3 normal) {
    vec3 diff = pos - center;
    float dist = length(diff);
    if (dist < radius) {
        normal = normalize(diff);
        hitPoint = center + normal * radius;
        return true;
    }
    return false;
}

bool checkBoxCollision(vec3 pos, vec3 boxMin, vec3 boxMax, out vec3 hitPoint, out vec3 normal) {
    // Check if inside box
    if (pos.x > boxMin.x && pos.x < boxMax.x &&
        pos.y > boxMin.y && pos.y < boxMax.y &&
        pos.z > boxMin.z && pos.z < boxMax.z) {

        // Find closest face
        float dxMin = pos.x - boxMin.x;
        float dxMax = boxMax.x - pos.x;
        float dyMin = pos.y - boxMin.y;
        float dyMax = boxMax.y - pos.y;
        float dzMin = pos.z - boxMin.z;
        float dzMax = boxMax.z - pos.z;

        float minDist = dxMin;
        normal = vec3(-1.0, 0.0, 0.0);
        hitPoint = vec3(boxMin.x, pos.y, pos.z);

        if (dxMax < minDist) {
            minDist = dxMax;
            normal = vec3(1.0, 0.0, 0.0);
            hitPoint = vec3(boxMax.x, pos.y, pos.z);
        }
        if (dyMin < minDist) {
            minDist = dyMin;
            normal = vec3(0.0, -1.0, 0.0);
            hitPoint = vec3(pos.x, boxMin.y, pos.z);
        }
        if (dyMax < minDist) {
            minDist = dyMax;
            normal = vec3(0.0, 1.0, 0.0);
            hitPoint = vec3(pos.x, boxMax.y, pos.z);
        }
        if (dzMin < minDist) {
            minDist = dzMin;
            normal = vec3(0.0, 0.0, -1.0);
            hitPoint = vec3(pos.x, pos.y, boxMin.z);
        }
        if (dzMax < minDist) {
            normal = vec3(0.0, 0.0, 1.0);
            hitPoint = vec3(pos.x, pos.y, boxMax.z);
        }

        return true;
    }
    return false;
}

void handleCollision(inout Particle p, vec3 normal, int response, float bounciness, uint particleIdx) {
    switch (response) {
        case RESPONSE_KILL:
            p.position.w = 0.0;
            break;

        case RESPONSE_BOUNCE:
        case RESPONSE_BOUNCE_DAMPED: {
            float bounceRoll = particleRandom(particleIdx, 2u);
            if (bounceRoll > uBounceChance) {
                p.position.w = 0.0;
                break;
            }

            vec3 reflectDir = reflect(p.velocity.xyz, normal);

            if (uBounceSpread > 0.0) {
                reflectDir = randomSpread(particleIdx, normalize(reflectDir), uBounceSpread) * length(reflectDir);
            }

            float damping = (response == RESPONSE_BOUNCE_DAMPED) ? bounciness : 1.0;
            p.velocity.xyz = reflectDir * damping;
            p.position.xyz += normal * 0.01;
            break;
        }

        case RESPONSE_STICK:
            p.velocity.xyz = vec3(0.0);
            p.position.xyz += normal * 0.01;
            break;

        case RESPONSE_SLIDE:
            p.velocity.xyz -= normal * dot(p.velocity.xyz, normal);
            p.position.xyz += normal * 0.01;
            break;
    }
}

// ==================== Main Function ====================

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uParticleCount) return;

    Particle p = particles[idx];

    // Check if alive
    if (p.position.w <= 0.0) return;

    // Track if particle was alive before this update
    bool wasAlive = true;

    // Calculate life percent before updating lifetime
    float lifePercent = 1.0 - (p.position.w / max(p.velocity.w, 0.001));
    lifePercent = clamp(lifePercent, 0.0, 1.0);

    // Update lifetime
    p.position.w -= uDeltaTime;

    if (p.position.w <= 0.0) {
        // Particle just died - record for sub-emitter
        if (uMaxDeadParticles > 0) {
            uint deadIdx = atomicCounterIncrement(deadCount);
            if (deadIdx < uMaxDeadParticles) {
                deadParticles[deadIdx] = vec4(p.position.xyz, length(p.velocity.xyz));
            }
        }

        p.position.w = 0.0;
        particles[idx] = p;
        return;
    }

    // Accumulate forces
    vec3 totalForce = vec3(0.0);
    for (int i = 0; i < uForceCount && i < 16; i++) {
        Force f = getForce(i);
        totalForce += applyForce(f, p.position.xyz, p.velocity.xyz);
    }

    // Update velocity (semi-implicit Euler)
    p.velocity.xyz += totalForce * uDeltaTime;

    // Apply velocity over lifetime multiplier
    vec3 velocityMultiplier = evaluateVelocityOverLifetime(lifePercent);
    vec3 effectiveVelocity = p.velocity.xyz * velocityMultiplier;

    // Update position using effective velocity
    p.position.xyz += effectiveVelocity * uDeltaTime;

    // Update rotation: base angular velocity + rotation over lifetime
    float baseAngularVelocity = p.params.w;
    float additionalAngularVelocity = evaluateRotationOverLifetime(lifePercent);
    p.params.y += (baseAngularVelocity + additionalAngularVelocity) * uDeltaTime;

    // Collision detection
    vec3 hitPoint, colNormal;
    if (uCollisionMode == COLLISION_PLANE) {
        if (checkPlaneCollision(p.position.xyz, p.velocity.xyz, uCollisionPlane, hitPoint, colNormal)) {
            handleCollision(p, colNormal, uCollisionResponse, uBounciness, idx);
        }
    } else if (uCollisionMode == COLLISION_SPHERE) {
        if (checkSphereCollision(p.position.xyz, uCollisionSphereCenter, uCollisionSphereRadius, hitPoint, colNormal)) {
            handleCollision(p, colNormal, uCollisionResponse, uBounciness, idx);
        }
    } else if (uCollisionMode == COLLISION_BOX) {
        if (checkBoxCollision(p.position.xyz, uCollisionBoxMin, uCollisionBoxMax, hitPoint, colNormal)) {
            handleCollision(p, colNormal, uCollisionResponse, uBounciness, idx);
        }
    }

    // Count alive particles
    if (p.position.w > 0.0) {
        atomicCounterIncrement(aliveCount);
    }

    particles[idx] = p;
}
